# Feature 2.3: Query Optimization

**Track:** 2 - Performance
**Dependencies:** 2.1 Pagination (should be complete)
**Estimated Tasks:** 8 atomic tasks

## Overview

Optimize database queries by using select instead of full includes, calculating totals in the database, and reducing N+1 query potential.

---

## Task List

- [ ] 2.3.1a Create dashboard statistics query
- [ ] 2.3.1b Calculate invoice totals in database
- [ ] 2.3.2a Optimize getInvoices to select only needed fields
- [ ] 2.3.2b Create invoice list type without full line items
- [ ] 2.3.3a Optimize getClients to select only needed fields
- [ ] 2.3.4a Add eager loading for invoice preview
- [ ] 2.3.5a Configure Prisma connection pooling
- [ ] 2.3.5b Add query logging in development

---

## Task Details

### 2.3.1a Create dashboard statistics query

**File:** `src/app/actions/invoices.ts`
**Action:** Add new function for dashboard stats

**Code to add:**
```typescript
export type DashboardStats = {
  totalOutstanding: number;
  totalPaid: number;
  totalOverdue: number;
  invoiceCount: number;
  overdueCount: number;
};

export async function getDashboardStats(): Promise<DashboardStats> {
  const userId = await getCurrentUserId();
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Get all invoices with their line items in a single query
  const invoices = await db.invoice.findMany({
    where: { userId },
    select: {
      status: true,
      dueDate: true,
      lineItems: {
        select: {
          quantity: true,
          unitPrice: true,
        },
      },
    },
  });

  let totalOutstanding = 0;
  let totalPaid = 0;
  let totalOverdue = 0;
  let overdueCount = 0;

  for (const invoice of invoices) {
    const total = invoice.lineItems.reduce(
      (sum, item) => sum + item.quantity.toNumber() * item.unitPrice.toNumber(),
      0
    );

    if (invoice.status === "paid") {
      totalPaid += total;
    } else {
      totalOutstanding += total;
      if (invoice.status === "sent" && new Date(invoice.dueDate) < today) {
        totalOverdue += total;
        overdueCount++;
      }
    }
  }

  return {
    totalOutstanding,
    totalPaid,
    totalOverdue,
    invoiceCount: invoices.length,
    overdueCount,
  };
}
```

**Note:** If tenant isolation (1.2) is not yet done, remove the `userId` line and filter.

**Verify:** Function exists and TypeScript compiles (`npm run typecheck`)

**Commit:** `feat(2.3.1a): create optimized dashboard statistics query`

---

### 2.3.1b Calculate invoice totals in database

**File:** `src/app/actions/invoices.ts`
**Action:** Add database-calculated total to invoice queries

**For complex totals, we can use Prisma's raw queries. Add this function:**
```typescript
export async function getInvoiceTotals(invoiceIds: string[]): Promise<Map<string, number>> {
  if (invoiceIds.length === 0) return new Map();

  const results = await db.$queryRaw<{ invoiceId: string; total: number }[]>`
    SELECT
      "invoiceId",
      SUM(quantity * "unitPrice") as total
    FROM "LineItem"
    WHERE "invoiceId" IN (${Prisma.join(invoiceIds)})
    GROUP BY "invoiceId"
  `;

  return new Map(results.map(r => [r.invoiceId, Number(r.total)]));
}
```

**Add import at top:**
```typescript
import { Prisma } from "@prisma/client";
```

**Verify:** Function exists and TypeScript compiles (`npm run typecheck`)

**Commit:** `feat(2.3.1b): add database-calculated invoice totals`

---

### 2.3.2a Optimize getInvoices to select only needed fields

**File:** `src/app/actions/invoices.ts`
**Action:** Create a lightweight version for list views

**Add new function:**
```typescript
export type InvoiceListItem = {
  id: string;
  invoiceNumber: string;
  clientName: string;
  status: string;
  dueDate: Date;
  total: number;
};

export async function getInvoicesList(
  clientId?: string,
  pagination: PaginationParams = { page: 1, pageSize: DEFAULT_PAGE_SIZE }
): Promise<PaginatedResult<InvoiceListItem>> {
  const userId = await getCurrentUserId();
  const { skip, take } = calculateSkipTake(pagination);

  const where = {
    userId,
    ...(clientId ? { clientId } : {}),
  };

  const [invoices, totalCount] = await Promise.all([
    db.invoice.findMany({
      where,
      select: {
        id: true,
        invoiceNumber: true,
        clientName: true,
        status: true,
        dueDate: true,
        lineItems: {
          select: {
            quantity: true,
            unitPrice: true,
          },
        },
      },
      orderBy: { createdAt: "desc" },
      skip,
      take,
    }),
    db.invoice.count({ where }),
  ]);

  const data: InvoiceListItem[] = invoices.map((invoice) => ({
    id: invoice.id,
    invoiceNumber: invoice.invoiceNumber,
    clientName: invoice.clientName,
    status: invoice.status,
    dueDate: invoice.dueDate,
    total: invoice.lineItems.reduce(
      (sum, item) => sum + item.quantity.toNumber() * item.unitPrice.toNumber(),
      0
    ),
  }));

  return {
    data,
    pagination: calculatePaginationMeta(totalCount, pagination),
  };
}
```

**Note:** If tenant isolation (1.2) is not yet done, remove the `userId` line and filter.

**Verify:** Function exists and TypeScript compiles (`npm run typecheck`)

**Commit:** `feat(2.3.2a): create optimized getInvoicesList for list views`

---

### 2.3.2b Create invoice list type without full line items

**File:** `src/app/page.tsx`
**Action:** Update dashboard to use getInvoicesList

**Change import:**
```typescript
import { getInvoicesList, getDashboardStats } from "@/app/actions/invoices";
```

**Update the data fetching:**
```typescript
const [{ data: invoices, pagination: paginationMeta }, stats] = await Promise.all([
  getInvoicesList(params.clientId, pagination),
  getDashboardStats(),
]);
```

**Update stat cards to use stats object:**
```typescript
<StatCard title="Outstanding" value={stats.totalOutstanding} />
<StatCard title="Paid" value={stats.totalPaid} />
<StatCard title="Overdue" value={stats.totalOverdue} count={stats.overdueCount} />
```

**Verify:** Dashboard uses optimized queries. Run `npm run typecheck`

**Commit:** `feat(2.3.2b): update dashboard to use optimized invoice list query`

---

### 2.3.3a Optimize getClients to select only needed fields

**File:** `src/app/actions/clients.ts`
**Action:** Create a lightweight version for list views

**Add new function:**
```typescript
export type ClientListItem = {
  id: string;
  name: string;
  email: string;
  invoiceCount: number;
  archivedAt: Date | null;
};

export async function getClientsList(
  includeArchived = false,
  pagination: PaginationParams = { page: 1, pageSize: DEFAULT_PAGE_SIZE }
): Promise<PaginatedResult<ClientListItem>> {
  const userId = await getCurrentUserId();
  const { skip, take } = calculateSkipTake(pagination);

  const where = {
    userId,
    ...(includeArchived ? {} : { archivedAt: null }),
  };

  const [clients, totalCount] = await Promise.all([
    db.client.findMany({
      where,
      select: {
        id: true,
        name: true,
        email: true,
        archivedAt: true,
        _count: { select: { invoices: true } },
      },
      orderBy: { name: "asc" },
      skip,
      take,
    }),
    db.client.count({ where }),
  ]);

  const data: ClientListItem[] = clients.map((client) => ({
    id: client.id,
    name: client.name,
    email: client.email,
    invoiceCount: client._count.invoices,
    archivedAt: client.archivedAt,
  }));

  return {
    data,
    pagination: calculatePaginationMeta(totalCount, pagination),
  };
}
```

**Note:** If tenant isolation (1.2) is not yet done, remove the `userId` line and filter.

**Verify:** Function exists and TypeScript compiles (`npm run typecheck`)

**Commit:** `feat(2.3.3a): create optimized getClientsList for list views`

---

### 2.3.4a Add eager loading for invoice preview

**File:** `src/app/actions/invoices.ts`
**Action:** Ensure getInvoice loads all needed data in one query

**The current getInvoice already includes lineItems. Verify it's optimal:**
```typescript
export async function getInvoice(id: string) {
  const userId = await getCurrentUserId();

  const invoice = await db.invoice.findFirst({
    where: { id, userId },
    include: {
      lineItems: true,
      client: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  if (!invoice) return null;

  return {
    ...invoice,
    lineItems: invoice.lineItems.map((item) => ({
      ...item,
      quantity: item.quantity.toNumber(),
      unitPrice: item.unitPrice.toNumber(),
    })),
  };
}
```

**Note:** If tenant isolation (1.2) is not yet done, use `findUnique` without userId filter.

**Verify:** getInvoice includes client data. Run `npm run typecheck`

**Commit:** `feat(2.3.4a): ensure invoice preview loads all data in single query`

---

### 2.3.5a Configure Prisma connection pooling

**File:** `src/lib/db.ts`
**Action:** Add connection pool configuration

**Update the Prisma client initialization:**
```typescript
import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const db =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
    datasources: {
      db: {
        url: process.env.DATABASE_URL,
      },
    },
  });

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = db;
```

**For production connection pooling, update DATABASE_URL in .env:**
```
DATABASE_URL="postgresql://user:pass@host:5432/db?connection_limit=10&pool_timeout=30"
```

**Verify:** Prisma client has logging config. Run `npm run typecheck`

**Commit:** `feat(2.3.5a): configure Prisma connection pooling and logging`

---

### 2.3.5b Add query logging in development

**File:** `src/lib/db.ts`
**Action:** Already done in previous task

**Verify:** Running `npm run dev` shows query logs in console when database operations occur.

**Commit:** `feat(2.3.5b): verify query logging in development mode`

---

## Progress Log

| Timestamp | Agent | Action | Task | Commit |
|-----------|-------|--------|------|--------|
| | | | | |
