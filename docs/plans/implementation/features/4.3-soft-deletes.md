# Feature 4.3: Soft Deletes for Invoices

**Track:** 4 - Data Integrity
**Dependencies:** None
**Estimated Tasks:** 10 atomic tasks

## Overview

Replace hard deletes with soft deletes for invoices to comply with financial record-keeping requirements and enable data recovery.

---

## Task List

- [ ] 4.3.1a Add archivedAt field to Invoice model
- [ ] 4.3.1b Run prisma db push for archivedAt
- [ ] 4.3.2a Update deleteInvoice to soft delete
- [ ] 4.3.2b Create restoreInvoice action
- [ ] 4.3.2c Create permanentDeleteInvoice action (admin only)
- [ ] 4.3.3a Update getInvoices to filter archived
- [ ] 4.3.3b Update getInvoice to include archived check
- [ ] 4.3.3c Update getDashboardStats to exclude archived
- [ ] 4.3.4a Add "show archived" toggle to dashboard
- [ ] 4.3.4b Add restore button to archived invoices

---

## Task Details

### 4.3.1a Add archivedAt field to Invoice model

**File:** `prisma/schema.prisma`
**Action:** Add archivedAt field to Invoice model

**Find the Invoice model and add the field:**
```prisma
model Invoice {
  id            String     @id @default(cuid())
  userId        String
  invoiceNumber String     @unique
  version       Int        @default(0)
  archivedAt    DateTime?                    // Add this line

  // ... rest of fields ...
}
```

**Verify:** Invoice model has archivedAt field

**Commit:** `feat(4.3.1a): add archivedAt field to Invoice model`

---

### 4.3.1b Run prisma db push for archivedAt

**Action:** Run command
**Command:**
```bash
npx prisma db push
npx prisma generate
```

**Verify:** Command completes without errors

**Commit:** `feat(4.3.1b): apply archivedAt field to database`

---

### 4.3.2a Update deleteInvoice to soft delete

**File:** `src/app/actions/invoices.ts`
**Action:** Change deleteInvoice to set archivedAt instead of deleting

**Replace deleteInvoice function:**
```typescript
export async function deleteInvoice(id: string) {
  const userId = await getCurrentUserId();
  const log = createLogger({ action: "archiveInvoice", userId, invoiceId: id });

  log.info("Archiving invoice");

  // Verify ownership
  const existing = await db.invoice.findFirst({
    where: { id, userId, archivedAt: null },
    select: { id: true, invoiceNumber: true },
  });

  if (!existing) {
    throw new Error("Invoice not found");
  }

  try {
    await db.invoice.update({
      where: { id },
      data: { archivedAt: new Date() },
    });

    log.info({ invoiceNumber: existing.invoiceNumber }, "Invoice archived successfully");
    revalidatePath("/");
    redirect("/");
  } catch (error) {
    log.error({ error }, "Failed to archive invoice");
    throw new Error("Failed to archive invoice. Please try again.");
  }
}

// Rename to be more explicit
export { deleteInvoice as archiveInvoice };
```

**Verify:** deleteInvoice performs soft delete. Run `npm run typecheck`

**Commit:** `feat(4.3.2a): change deleteInvoice to soft delete (archive)`

---

### 4.3.2b Create restoreInvoice action

**File:** `src/app/actions/invoices.ts`
**Action:** Add restoreInvoice function

**Code to add:**
```typescript
export async function restoreInvoice(id: string) {
  const userId = await getCurrentUserId();
  const log = createLogger({ action: "restoreInvoice", userId, invoiceId: id });

  log.info("Restoring invoice");

  // Verify ownership (including archived invoices)
  const existing = await db.invoice.findFirst({
    where: { id, userId },
    select: { id: true, invoiceNumber: true, archivedAt: true },
  });

  if (!existing) {
    throw new Error("Invoice not found");
  }

  if (!existing.archivedAt) {
    throw new Error("Invoice is not archived");
  }

  try {
    await db.invoice.update({
      where: { id },
      data: { archivedAt: null },
    });

    log.info({ invoiceNumber: existing.invoiceNumber }, "Invoice restored successfully");
    revalidatePath("/");
    revalidatePath(`/invoices/${id}`);
  } catch (error) {
    log.error({ error }, "Failed to restore invoice");
    throw new Error("Failed to restore invoice. Please try again.");
  }
}
```

**Verify:** restoreInvoice function exists. Run `npm run typecheck`

**Commit:** `feat(4.3.2b): create restoreInvoice action`

---

### 4.3.2c Create permanentDeleteInvoice action (admin only)

**File:** `src/app/actions/invoices.ts`
**Action:** Add permanentDeleteInvoice function for compliance edge cases

**Code to add:**
```typescript
/**
 * Permanently delete an invoice. Use with caution.
 * This should only be used for:
 * - Test data cleanup
 * - GDPR right-to-erasure requests
 * - Compliance-mandated data destruction
 */
export async function permanentDeleteInvoice(id: string) {
  const userId = await getCurrentUserId();
  const log = createLogger({ action: "permanentDeleteInvoice", userId, invoiceId: id });

  log.warn("Permanently deleting invoice");

  // Verify ownership
  const existing = await db.invoice.findFirst({
    where: { id, userId },
    select: { id: true, invoiceNumber: true, archivedAt: true },
  });

  if (!existing) {
    throw new Error("Invoice not found");
  }

  // Only allow permanent deletion of archived invoices
  if (!existing.archivedAt) {
    throw new Error("Invoice must be archived before permanent deletion");
  }

  try {
    await db.$transaction(async (tx) => {
      await tx.lineItem.deleteMany({ where: { invoiceId: id } });
      await tx.invoice.delete({ where: { id } });
    });

    log.warn(
      { invoiceNumber: existing.invoiceNumber },
      "Invoice permanently deleted"
    );
    revalidatePath("/");
  } catch (error) {
    log.error({ error }, "Failed to permanently delete invoice");
    throw new Error("Failed to delete invoice. Please try again.");
  }
}
```

**Verify:** permanentDeleteInvoice function exists. Run `npm run typecheck`

**Commit:** `feat(4.3.2c): create permanentDeleteInvoice action for compliance`

---

### 4.3.3a Update getInvoices to filter archived

**File:** `src/app/actions/invoices.ts`
**Action:** Modify getInvoices to exclude archived by default

**Update getInvoices function signature:**
```typescript
export async function getInvoices(
  clientId?: string,
  pagination: PaginationParams = { page: 1, pageSize: DEFAULT_PAGE_SIZE },
  includeArchived = false
)
```

**Update the where clause:**
```typescript
  const where = {
    userId,
    ...(clientId ? { clientId } : {}),
    ...(includeArchived ? {} : { archivedAt: null }),
  };
```

**Also update getInvoicesList if it exists:**
```typescript
export async function getInvoicesList(
  clientId?: string,
  pagination: PaginationParams = { page: 1, pageSize: DEFAULT_PAGE_SIZE },
  includeArchived = false
): Promise<PaginatedResult<InvoiceListItem>> {
  const userId = await getCurrentUserId();
  const { skip, take } = calculateSkipTake(pagination);

  const where = {
    userId,
    ...(clientId ? { clientId } : {}),
    ...(includeArchived ? {} : { archivedAt: null }),
  };

  // ... rest of function ...
}
```

**Verify:** getInvoices filters out archived invoices by default. Run `npm run typecheck`

**Commit:** `feat(4.3.3a): update getInvoices to filter archived invoices`

---

### 4.3.3b Update getInvoice to include archived check

**File:** `src/app/actions/invoices.ts`
**Action:** Modify getInvoice to optionally include archived

**Update getInvoice function:**
```typescript
export async function getInvoice(id: string, includeArchived = false) {
  const userId = await getCurrentUserId();

  const invoice = await db.invoice.findFirst({
    where: {
      id,
      userId,
      ...(includeArchived ? {} : { archivedAt: null }),
    },
    include: {
      lineItems: true,
      client: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  if (!invoice) return null;

  return {
    ...invoice,
    lineItems: invoice.lineItems.map((item) => ({
      ...item,
      quantity: item.quantity.toNumber(),
      unitPrice: item.unitPrice.toNumber(),
    })),
  };
}
```

**Verify:** getInvoice handles archived invoices. Run `npm run typecheck`

**Commit:** `feat(4.3.3b): update getInvoice to handle archived invoices`

---

### 4.3.3c Update getDashboardStats to exclude archived

**File:** `src/app/actions/invoices.ts`
**Action:** Modify getDashboardStats to exclude archived invoices

**Update the where clause in getDashboardStats:**
```typescript
export async function getDashboardStats(): Promise<DashboardStats> {
  const userId = await getCurrentUserId();
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Exclude archived invoices from stats
  const invoices = await db.invoice.findMany({
    where: {
      userId,
      archivedAt: null,  // Add this filter
    },
    select: {
      status: true,
      dueDate: true,
      lineItems: {
        select: {
          quantity: true,
          unitPrice: true,
        },
      },
    },
  });

  // ... rest of function ...
}
```

**Verify:** Dashboard stats exclude archived invoices. Run `npm run typecheck`

**Commit:** `feat(4.3.3c): exclude archived invoices from dashboard stats`

---

### 4.3.4a Add "show archived" toggle to dashboard

**File:** `src/app/page.tsx`
**Action:** Add toggle to show/hide archived invoices

**Add to the dashboard page:**
```typescript
export default async function Dashboard({
  searchParams,
}: {
  searchParams: Promise<{ page?: string; clientId?: string; showArchived?: string }>;
}) {
  const params = await searchParams;
  const pagination = parsePaginationParams(params);
  const showArchived = params.showArchived === "true";

  const [{ data: invoices, pagination: paginationMeta }, stats] = await Promise.all([
    getInvoicesList(params.clientId, pagination, showArchived),
    getDashboardStats(),
  ]);

  // ... rest of component ...
}
```

**Add toggle UI component before the invoice table:**
```typescript
import Link from "next/link";

// In the component:
<div className="flex justify-between items-center mb-4">
  <h2 className="text-xl font-semibold">Invoices</h2>
  <Link
    href={showArchived ? "/" : "/?showArchived=true"}
    className="text-sm text-blue-600 hover:underline"
  >
    {showArchived ? "Hide archived" : "Show archived"}
  </Link>
</div>
```

**Verify:** Toggle appears on dashboard. Run `npm run typecheck`

**Commit:** `feat(4.3.4a): add show archived toggle to dashboard`

---

### 4.3.4b Add restore button to archived invoices

**File:** `src/components/invoice-actions.tsx`
**Action:** Create new component for invoice row actions

**Code:**
```typescript
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { archiveInvoice, restoreInvoice } from "@/app/actions/invoices";

type InvoiceActionsProps = {
  invoiceId: string;
  isArchived: boolean;
};

export function InvoiceActions({ invoiceId, isArchived }: InvoiceActionsProps) {
  const router = useRouter();
  const [loading, setLoading] = useState(false);

  async function handleArchive() {
    if (!confirm("Are you sure you want to archive this invoice?")) return;

    setLoading(true);
    try {
      await archiveInvoice(invoiceId);
      router.refresh();
    } catch (error) {
      alert(error instanceof Error ? error.message : "Failed to archive invoice");
    } finally {
      setLoading(false);
    }
  }

  async function handleRestore() {
    setLoading(true);
    try {
      await restoreInvoice(invoiceId);
      router.refresh();
    } catch (error) {
      alert(error instanceof Error ? error.message : "Failed to restore invoice");
    } finally {
      setLoading(false);
    }
  }

  if (isArchived) {
    return (
      <Button
        variant="outline"
        size="sm"
        onClick={handleRestore}
        disabled={loading}
      >
        {loading ? "Restoring..." : "Restore"}
      </Button>
    );
  }

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={handleArchive}
      disabled={loading}
      className="text-red-600 hover:text-red-700"
    >
      {loading ? "Archiving..." : "Archive"}
    </Button>
  );
}
```

**File:** `src/app/page.tsx`
**Action:** Use InvoiceActions in the invoice table

**Import and use the component:**
```typescript
import { InvoiceActions } from "@/components/invoice-actions";

// In the table row:
<TableCell>
  <InvoiceActions
    invoiceId={invoice.id}
    isArchived={!!invoice.archivedAt}
  />
</TableCell>
```

**Note:** You'll need to add archivedAt to the InvoiceListItem type and return it from getInvoicesList.

**Verify:** Archive/Restore buttons work correctly. Run `npm run typecheck`

**Commit:** `feat(4.3.4b): add archive and restore buttons to invoice table`

---

## Progress Log

| Timestamp | Agent | Action | Task | Commit |
|-----------|-------|--------|------|--------|
| | | | | |
