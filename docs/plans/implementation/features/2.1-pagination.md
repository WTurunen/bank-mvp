# Feature 2.1: Pagination

**Track:** 2 - Performance
**Dependencies:** None
**Estimated Tasks:** 12 atomic tasks

## Overview

Add pagination to prevent loading all records at once. The dashboard currently fetches ALL invoices, which will cause performance issues as data grows.

---

## Task List

- [ ] 2.1.1a Create pagination types
- [ ] 2.1.1b Create pagination utility functions
- [ ] 2.1.2a Update getInvoices to accept pagination params
- [ ] 2.1.2b Update getInvoices to return pagination metadata
- [ ] 2.1.2c Update getClients to accept pagination params
- [ ] 2.1.2d Update getClients to return pagination metadata
- [ ] 2.1.3a Create pagination component
- [ ] 2.1.3b Add pagination component styles
- [ ] 2.1.4a Update dashboard page to use pagination
- [ ] 2.1.4b Add URL search params for page state
- [ ] 2.1.5a Update clients page to use pagination
- [ ] 2.1.5b Add URL search params to clients page

---

## Task Details

### 2.1.1a Create pagination types

**File:** `src/lib/pagination.ts`
**Action:** Create new file

**Code:**
```typescript
export type PaginationParams = {
  page: number;
  pageSize: number;
};

export type PaginationMeta = {
  page: number;
  pageSize: number;
  totalCount: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPrevPage: boolean;
};

export type PaginatedResult<T> = {
  data: T[];
  pagination: PaginationMeta;
};

export const DEFAULT_PAGE_SIZE = 20;
export const MAX_PAGE_SIZE = 100;
```

**Verify:** File exists and TypeScript compiles (`npm run typecheck`)

**Commit:** `feat(2.1.1a): create pagination types`

---

### 2.1.1b Create pagination utility functions

**File:** `src/lib/pagination.ts`
**Action:** Add to existing file

**Code to add:**
```typescript
export function parsePaginationParams(
  searchParams: { page?: string; pageSize?: string }
): PaginationParams {
  const page = Math.max(1, parseInt(searchParams.page || "1", 10) || 1);
  const rawPageSize = parseInt(searchParams.pageSize || String(DEFAULT_PAGE_SIZE), 10) || DEFAULT_PAGE_SIZE;
  const pageSize = Math.min(Math.max(1, rawPageSize), MAX_PAGE_SIZE);

  return { page, pageSize };
}

export function calculatePaginationMeta(
  totalCount: number,
  params: PaginationParams
): PaginationMeta {
  const totalPages = Math.ceil(totalCount / params.pageSize);
  const page = Math.min(params.page, Math.max(1, totalPages));

  return {
    page,
    pageSize: params.pageSize,
    totalCount,
    totalPages,
    hasNextPage: page < totalPages,
    hasPrevPage: page > 1,
  };
}

export function calculateSkipTake(params: PaginationParams): {
  skip: number;
  take: number;
} {
  return {
    skip: (params.page - 1) * params.pageSize,
    take: params.pageSize,
  };
}
```

**Verify:** Functions added and TypeScript compiles (`npm run typecheck`)

**Commit:** `feat(2.1.1b): create pagination utility functions`

---

### 2.1.2a Update getInvoices to accept pagination params

**File:** `src/app/actions/invoices.ts`
**Action:** Modify getInvoices function

**Add import at top:**
```typescript
import {
  PaginationParams,
  PaginatedResult,
  DEFAULT_PAGE_SIZE,
  calculateSkipTake,
  calculatePaginationMeta,
} from "@/lib/pagination";
```

**Find this code:**
```typescript
export async function getInvoices(clientId?: string) {
```

**Replace with:**
```typescript
export async function getInvoices(
  clientId?: string,
  pagination: PaginationParams = { page: 1, pageSize: DEFAULT_PAGE_SIZE }
) {
```

**Verify:** Function accepts pagination params. Run `npm run typecheck`

**Commit:** `feat(2.1.2a): update getInvoices to accept pagination params`

---

### 2.1.2b Update getInvoices to return pagination metadata

**File:** `src/app/actions/invoices.ts`
**Action:** Modify getInvoices function body

**Replace the entire getInvoices function with:**
```typescript
export async function getInvoices(
  clientId?: string,
  pagination: PaginationParams = { page: 1, pageSize: DEFAULT_PAGE_SIZE }
): Promise<PaginatedResult<ReturnType<typeof formatInvoice>>> {
  const userId = await getCurrentUserId();
  const { skip, take } = calculateSkipTake(pagination);

  const where = {
    userId,
    ...(clientId ? { clientId } : {}),
  };

  const [invoices, totalCount] = await Promise.all([
    db.invoice.findMany({
      where,
      include: { lineItems: true },
      orderBy: { createdAt: "desc" },
      skip,
      take,
    }),
    db.invoice.count({ where }),
  ]);

  const data = invoices.map((invoice) => ({
    ...invoice,
    lineItems: invoice.lineItems.map((item) => ({
      ...item,
      quantity: item.quantity.toNumber(),
      unitPrice: item.unitPrice.toNumber(),
    })),
  }));

  return {
    data,
    pagination: calculatePaginationMeta(totalCount, pagination),
  };
}
```

**Note:** If tenant isolation (1.2) is not yet done, remove the `userId` line and `userId` from the where clause.

**Verify:** Function returns paginated result. Run `npm run typecheck`

**Commit:** `feat(2.1.2b): update getInvoices to return pagination metadata`

---

### 2.1.2c Update getClients to accept pagination params

**File:** `src/app/actions/clients.ts`
**Action:** Modify getClients function

**Add import at top:**
```typescript
import {
  PaginationParams,
  PaginatedResult,
  DEFAULT_PAGE_SIZE,
  calculateSkipTake,
  calculatePaginationMeta,
} from "@/lib/pagination";
```

**Find this code:**
```typescript
export async function getClients(includeArchived = false) {
```

**Replace with:**
```typescript
export async function getClients(
  includeArchived = false,
  pagination: PaginationParams = { page: 1, pageSize: DEFAULT_PAGE_SIZE }
) {
```

**Verify:** Function accepts pagination params. Run `npm run typecheck`

**Commit:** `feat(2.1.2c): update getClients to accept pagination params`

---

### 2.1.2d Update getClients to return pagination metadata

**File:** `src/app/actions/clients.ts`
**Action:** Modify getClients function body

**Replace the entire getClients function with:**
```typescript
export async function getClients(
  includeArchived = false,
  pagination: PaginationParams = { page: 1, pageSize: DEFAULT_PAGE_SIZE }
) {
  const userId = await getCurrentUserId();
  const { skip, take } = calculateSkipTake(pagination);

  const where = {
    userId,
    ...(includeArchived ? {} : { archivedAt: null }),
  };

  const [clients, totalCount] = await Promise.all([
    db.client.findMany({
      where,
      include: { _count: { select: { invoices: true } } },
      orderBy: { name: "asc" },
      skip,
      take,
    }),
    db.client.count({ where }),
  ]);

  return {
    data: clients,
    pagination: calculatePaginationMeta(totalCount, pagination),
  };
}
```

**Note:** If tenant isolation (1.2) is not yet done, remove the `userId` line and `userId` from the where clause.

**Verify:** Function returns paginated result. Run `npm run typecheck`

**Commit:** `feat(2.1.2d): update getClients to return pagination metadata`

---

### 2.1.3a Create pagination component

**File:** `src/components/pagination.tsx`
**Action:** Create new file

**Code:**
```typescript
"use client";

import { useRouter, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import type { PaginationMeta } from "@/lib/pagination";

type PaginationProps = {
  pagination: PaginationMeta;
};

export function Pagination({ pagination }: PaginationProps) {
  const router = useRouter();
  const searchParams = useSearchParams();

  const { page, totalPages, hasNextPage, hasPrevPage, totalCount } = pagination;

  function goToPage(newPage: number) {
    const params = new URLSearchParams(searchParams.toString());
    params.set("page", String(newPage));
    router.push(`?${params.toString()}`);
  }

  if (totalPages <= 1) {
    return null;
  }

  return (
    <div className="flex items-center justify-between py-4">
      <p className="text-sm text-gray-600">
        Page {page} of {totalPages} ({totalCount} total)
      </p>
      <div className="flex gap-2">
        <Button
          variant="outline"
          size="sm"
          onClick={() => goToPage(page - 1)}
          disabled={!hasPrevPage}
        >
          Previous
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => goToPage(page + 1)}
          disabled={!hasNextPage}
        >
          Next
        </Button>
      </div>
    </div>
  );
}
```

**Verify:** Component exists and TypeScript compiles (`npm run typecheck`)

**Commit:** `feat(2.1.3a): create pagination component`

---

### 2.1.3b Add pagination component styles

**File:** `src/components/pagination.tsx`
**Action:** Add page number buttons (enhancement)

**Replace the component with this enhanced version:**
```typescript
"use client";

import { useRouter, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import type { PaginationMeta } from "@/lib/pagination";

type PaginationProps = {
  pagination: PaginationMeta;
};

export function Pagination({ pagination }: PaginationProps) {
  const router = useRouter();
  const searchParams = useSearchParams();

  const { page, totalPages, hasNextPage, hasPrevPage, totalCount } = pagination;

  function goToPage(newPage: number) {
    const params = new URLSearchParams(searchParams.toString());
    params.set("page", String(newPage));
    router.push(`?${params.toString()}`);
  }

  if (totalPages <= 1) {
    return null;
  }

  // Generate page numbers to show
  const pageNumbers: (number | "...")[] = [];
  if (totalPages <= 7) {
    for (let i = 1; i <= totalPages; i++) {
      pageNumbers.push(i);
    }
  } else {
    pageNumbers.push(1);
    if (page > 3) pageNumbers.push("...");
    for (let i = Math.max(2, page - 1); i <= Math.min(totalPages - 1, page + 1); i++) {
      pageNumbers.push(i);
    }
    if (page < totalPages - 2) pageNumbers.push("...");
    pageNumbers.push(totalPages);
  }

  return (
    <div className="flex items-center justify-between py-4">
      <p className="text-sm text-gray-600">
        Page {page} of {totalPages} ({totalCount} total)
      </p>
      <div className="flex gap-1">
        <Button
          variant="outline"
          size="sm"
          onClick={() => goToPage(page - 1)}
          disabled={!hasPrevPage}
        >
          Previous
        </Button>
        {pageNumbers.map((num, idx) =>
          num === "..." ? (
            <span key={`ellipsis-${idx}`} className="px-2 py-1">
              ...
            </span>
          ) : (
            <Button
              key={num}
              variant={num === page ? "default" : "outline"}
              size="sm"
              onClick={() => goToPage(num)}
            >
              {num}
            </Button>
          )
        )}
        <Button
          variant="outline"
          size="sm"
          onClick={() => goToPage(page + 1)}
          disabled={!hasNextPage}
        >
          Next
        </Button>
      </div>
    </div>
  );
}
```

**Verify:** Component shows page numbers. Run `npm run typecheck`

**Commit:** `feat(2.1.3b): add page number buttons to pagination component`

---

### 2.1.4a Update dashboard page to use pagination

**File:** `src/app/page.tsx`
**Action:** Modify to use paginated getInvoices

**Add import:**
```typescript
import { parsePaginationParams } from "@/lib/pagination";
import { Pagination } from "@/components/pagination";
```

**Update the page component to accept searchParams:**
```typescript
export default async function Dashboard({
  searchParams,
}: {
  searchParams: Promise<{ page?: string; clientId?: string }>;
}) {
  const params = await searchParams;
  const pagination = parsePaginationParams(params);
  const { data: invoices, pagination: paginationMeta } = await getInvoices(
    params.clientId,
    pagination
  );
```

**Add Pagination component after the invoice table:**
```typescript
<Pagination pagination={paginationMeta} />
```

**Verify:** Dashboard shows paginated invoices. Run `npm run typecheck`

**Commit:** `feat(2.1.4a): update dashboard page to use pagination`

---

### 2.1.4b Add URL search params for page state

**File:** `src/app/page.tsx`
**Action:** Ensure page state persists in URL

**The previous task already handles this via the Pagination component's `goToPage` function which updates URL params.**

**Verify:** Clicking pagination updates URL, refreshing page maintains position

**Commit:** `feat(2.1.4b): verify URL search params persist page state`

---

### 2.1.5a Update clients page to use pagination

**File:** `src/app/clients/page.tsx`
**Action:** Modify to use paginated getClients

**Add import:**
```typescript
import { parsePaginationParams } from "@/lib/pagination";
import { Pagination } from "@/components/pagination";
```

**Update the page component to accept searchParams:**
```typescript
export default async function ClientsPage({
  searchParams,
}: {
  searchParams: Promise<{ page?: string; archived?: string }>;
}) {
  const params = await searchParams;
  const pagination = parsePaginationParams(params);
  const includeArchived = params.archived === "true";
  const { data: clients, pagination: paginationMeta } = await getClients(
    includeArchived,
    pagination
  );
```

**Add Pagination component after the clients table:**
```typescript
<Pagination pagination={paginationMeta} />
```

**Verify:** Clients page shows paginated clients. Run `npm run typecheck`

**Commit:** `feat(2.1.5a): update clients page to use pagination`

---

### 2.1.5b Add URL search params to clients page

**File:** `src/app/clients/page.tsx`
**Action:** Ensure page state persists in URL

**The previous task already handles this via the Pagination component.**

**Verify:** Clicking pagination on clients page updates URL

**Commit:** `feat(2.1.5b): verify URL search params on clients page`

---

## Progress Log

| Timestamp | Agent | Action | Task | Commit |
|-----------|-------|--------|------|--------|
| | | | | |
