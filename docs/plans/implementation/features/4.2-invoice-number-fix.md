# Feature 4.2: Invoice Number Race Condition Fix

**Track:** 4 - Data Integrity
**Dependencies:** None
**Estimated Tasks:** 8 atomic tasks

## Overview

Fix the race condition in invoice number generation. The current implementation can generate duplicate numbers under concurrent load because it reads the latest number and increments it without locking.

---

## Task List

- [ ] 4.2.1a Create InvoiceCounter model in schema
- [ ] 4.2.1b Run prisma db push for counter
- [ ] 4.2.1c Seed initial counter value
- [ ] 4.2.2a Create atomic increment function
- [ ] 4.2.2b Update generateInvoiceNumber to use counter
- [ ] 4.2.3a Add unique constraint retry logic
- [ ] 4.2.3b Add per-tenant invoice numbering (if tenant isolation done)
- [ ] 4.2.4a Add test for concurrent invoice creation

---

## Task Details

### 4.2.1a Create InvoiceCounter model in schema

**File:** `prisma/schema.prisma`
**Action:** Add InvoiceCounter model

**Code to add at end of file:**
```prisma
model InvoiceCounter {
  id        String   @id @default("default")
  counter   Int      @default(0)
  updatedAt DateTime @updatedAt
}
```

**Note:** Using a single row with id="default". For multi-tenant, use id=tenantId.

**Verify:** Model added to schema

**Commit:** `feat(4.2.1a): add InvoiceCounter model to schema`

---

### 4.2.1b Run prisma db push for counter

**Action:** Run command
**Command:**
```bash
npx prisma db push
npx prisma generate
```

**Verify:** Command completes without errors

**Commit:** `feat(4.2.1b): apply InvoiceCounter model to database`

---

### 4.2.1c Seed initial counter value

**File:** `prisma/seed.ts`
**Action:** Add counter initialization

**Add to the seed file:**
```typescript
async function seedInvoiceCounter() {
  // Find the highest existing invoice number
  const latestInvoice = await prisma.invoice.findFirst({
    orderBy: { invoiceNumber: "desc" },
    select: { invoiceNumber: true },
  });

  let counter = 0;
  if (latestInvoice) {
    const match = latestInvoice.invoiceNumber.match(/INV-(\d+)/);
    if (match) {
      counter = parseInt(match[1], 10);
    }
  }

  await prisma.invoiceCounter.upsert({
    where: { id: "default" },
    update: { counter },
    create: { id: "default", counter },
  });

  console.log(`Invoice counter initialized to ${counter}`);
}

// Call in main seed function
async function main() {
  // ... existing seed code ...
  await seedInvoiceCounter();
}
```

**Run seed:**
```bash
npx prisma db seed
```

**Verify:** Counter record exists in database

**Commit:** `feat(4.2.1c): seed initial invoice counter value`

---

### 4.2.2a Create atomic increment function

**File:** `src/lib/invoice-number.ts`
**Action:** Create new file

**Code:**
```typescript
import { db } from "@/lib/db";
import { createLogger } from "@/lib/logger";

const log = createLogger({ action: "generateInvoiceNumber" });

/**
 * Atomically generates the next invoice number using database counter.
 * Uses UPDATE ... RETURNING to ensure atomic increment.
 */
export async function getNextInvoiceNumber(tenantId = "default"): Promise<string> {
  // Use raw SQL for atomic increment with RETURNING
  const result = await db.$queryRaw<{ counter: number }[]>`
    UPDATE "InvoiceCounter"
    SET counter = counter + 1, "updatedAt" = NOW()
    WHERE id = ${tenantId}
    RETURNING counter
  `;

  if (result.length === 0) {
    // Counter doesn't exist, create it atomically
    log.warn({ tenantId }, "Counter not found, creating new counter");

    // Insert with conflict handling
    await db.$executeRaw`
      INSERT INTO "InvoiceCounter" (id, counter, "updatedAt")
      VALUES (${tenantId}, 1, NOW())
      ON CONFLICT (id) DO UPDATE SET counter = "InvoiceCounter".counter + 1
    `;

    // Fetch the current value
    const newResult = await db.$queryRaw<{ counter: number }[]>`
      SELECT counter FROM "InvoiceCounter" WHERE id = ${tenantId}
    `;

    if (newResult.length === 0) {
      throw new Error("Failed to initialize invoice counter");
    }

    return formatInvoiceNumber(newResult[0].counter);
  }

  return formatInvoiceNumber(result[0].counter);
}

function formatInvoiceNumber(counter: number): string {
  return `INV-${String(counter).padStart(3, "0")}`;
}
```

**Verify:** File exists and TypeScript compiles (`npm run typecheck`)

**Commit:** `feat(4.2.2a): create atomic invoice number increment function`

---

### 4.2.2b Update generateInvoiceNumber to use counter

**File:** `src/app/actions/invoices.ts`
**Action:** Replace generateInvoiceNumber function

**Remove the old function:**
```typescript
// DELETE THIS:
async function generateInvoiceNumber(): Promise<string> {
  const latest = await db.invoice.findFirst({
    orderBy: { invoiceNumber: "desc" },
    select: { invoiceNumber: true },
  });

  if (!latest) return "INV-001";

  const num = parseInt(latest.invoiceNumber.replace("INV-", ""), 10);
  return `INV-${String(num + 1).padStart(3, "0")}`;
}
```

**Add import:**
```typescript
import { getNextInvoiceNumber } from "@/lib/invoice-number";
```

**Update createInvoice to use the new function:**
```typescript
export async function createInvoice(data: InvoiceInput) {
  const userId = await getCurrentUserId();
  // ...validation...

  const invoiceNumber = await getNextInvoiceNumber();

  // ... rest of function ...
}
```

**Verify:** createInvoice uses getNextInvoiceNumber. Run `npm run typecheck`

**Commit:** `feat(4.2.2b): update createInvoice to use atomic invoice number generation`

---

### 4.2.3a Add unique constraint retry logic

**File:** `src/app/actions/invoices.ts`
**Action:** Add retry logic for unique constraint violations

**Modify createInvoice to handle the (rare) case where two requests get the same number:**
```typescript
export async function createInvoice(data: InvoiceInput) {
  const userId = await getCurrentUserId();
  const log = createLogger({ action: "createInvoice", userId });

  // ... validation code ...

  const MAX_RETRIES = 3;

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    const invoiceNumber = await getNextInvoiceNumber();

    try {
      const invoice = await db.invoice.create({
        data: {
          userId,
          invoiceNumber,
          clientId: data.clientId,
          clientName: data.clientName,
          clientEmail: data.clientEmail,
          clientPhone: data.clientPhone,
          clientAddress: data.clientAddress,
          dueDate: new Date(data.dueDate),
          notes: data.notes || null,
          lineItems: {
            create: data.lineItems.map((item) => ({
              description: item.description,
              quantity: item.quantity,
              unitPrice: item.unitPrice,
            })),
          },
        },
      });

      log.info({ invoiceId: invoice.id, invoiceNumber }, "Invoice created successfully");
      revalidatePath("/");
      return invoice.id;
    } catch (error) {
      // Check for unique constraint violation on invoiceNumber
      if (
        error instanceof Error &&
        "code" in error &&
        (error as { code: string }).code === "P2002"
      ) {
        log.warn(
          { invoiceNumber, attempt },
          "Invoice number conflict, retrying"
        );
        if (attempt === MAX_RETRIES) {
          throw new Error("Failed to generate unique invoice number");
        }
        continue;
      }
      throw error;
    }
  }

  throw new Error("Failed to create invoice");
}
```

**Verify:** createInvoice has retry logic. Run `npm run typecheck`

**Commit:** `feat(4.2.3a): add unique constraint retry logic to createInvoice`

---

### 4.2.3b Add per-tenant invoice numbering (if tenant isolation done)

**File:** `src/lib/invoice-number.ts`
**Action:** Update to use userId as tenant ID

**If Feature 1.2 (tenant isolation) is complete, update getNextInvoiceNumber:**
```typescript
export async function getNextInvoiceNumber(userId: string): Promise<string> {
  // Use userId as the counter key for per-tenant numbering
  const tenantId = userId;

  const result = await db.$queryRaw<{ counter: number }[]>`
    UPDATE "InvoiceCounter"
    SET counter = counter + 1, "updatedAt" = NOW()
    WHERE id = ${tenantId}
    RETURNING counter
  `;

  // ... rest of function with tenantId ...
}
```

**Update createInvoice call:**
```typescript
const invoiceNumber = await getNextInvoiceNumber(userId);
```

**Verify:** Each user gets their own invoice number sequence. Run `npm run typecheck`

**Commit:** `feat(4.2.3b): implement per-tenant invoice numbering`

---

### 4.2.4a Add test for concurrent invoice creation

**File:** `src/app/actions/invoices.test.ts`
**Action:** Add concurrent creation test

**Code to add:**
```typescript
describe("createInvoice - concurrency", () => {
  let testUser: { id: string; email: string; name: string | null };
  let testClient: { id: string; name: string; email: string };

  beforeEach(async () => {
    await setupTestDb();
    resetCounters();
    testUser = await createTestUser();
    testClient = await createTestClient(testUser.id);
    setMockUser({
      id: testUser.id,
      email: testUser.email,
      name: testUser.name || "Test User",
    });

    // Initialize counter
    await testDb.invoiceCounter.upsert({
      where: { id: "default" },
      update: { counter: 0 },
      create: { id: "default", counter: 0 },
    });
  });

  afterEach(async () => {
    clearMockUser();
    await teardownTestDb();
  });

  it("generates unique invoice numbers under concurrent load", async () => {
    const invoiceData = {
      clientName: testClient.name,
      clientEmail: testClient.email,
      dueDate: "2024-12-31",
      lineItems: [{ description: "Service", quantity: 1, unitPrice: 100 }],
    };

    // Create 10 invoices concurrently
    const promises = Array.from({ length: 10 }, () =>
      createInvoice({ ...invoiceData })
    );

    const invoiceIds = await Promise.all(promises);

    // Verify all invoices were created
    expect(invoiceIds).toHaveLength(10);

    // Verify all invoice numbers are unique
    const invoices = await testDb.invoice.findMany({
      where: { id: { in: invoiceIds } },
      select: { invoiceNumber: true },
    });

    const numbers = invoices.map((i) => i.invoiceNumber);
    const uniqueNumbers = new Set(numbers);

    expect(uniqueNumbers.size).toBe(10);
  });
});
```

**Verify:** Test passes with `npm run test:run src/app/actions/invoices.test.ts`

**Commit:** `test(4.2.4a): add concurrent invoice creation test`

---

## Progress Log

| Timestamp | Agent | Action | Task | Commit |
|-----------|-------|--------|------|--------|
| | | | | |
