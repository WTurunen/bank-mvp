# Feature 4.1: Database Transactions

**Track:** 4 - Data Integrity
**Dependencies:** None
**Estimated Tasks:** 8 atomic tasks

## Overview

Wrap multi-step database operations in transactions to prevent data corruption from partial failures or concurrent operations.

---

## Task List

- [ ] 4.1.1a Wrap updateInvoice in transaction
- [ ] 4.1.1b Handle transaction errors in updateInvoice
- [ ] 4.1.2a Wrap deleteInvoice in transaction
- [ ] 4.1.2b Add pre-delete checks in transaction
- [ ] 4.1.3a Add version field for optimistic locking
- [ ] 4.1.3b Implement optimistic locking in updateInvoice
- [ ] 4.1.4a Create transaction helper utility
- [ ] 4.1.4b Add transaction retry logic

---

## Task Details

### 4.1.1a Wrap updateInvoice in transaction

**File:** `src/app/actions/invoices.ts`
**Action:** Modify updateInvoice to use transaction

**Find the updateInvoice function. Replace the database operations with a transaction:**

**Before:**
```typescript
  await db.lineItem.deleteMany({ where: { invoiceId: id } });

  await db.invoice.update({
    where: { id },
    data: {
      // ...
    },
  });
```

**After:**
```typescript
  await db.$transaction(async (tx) => {
    await tx.lineItem.deleteMany({ where: { invoiceId: id } });

    await tx.invoice.update({
      where: { id },
      data: {
        clientId: data.clientId,
        clientName: data.clientName,
        clientEmail: data.clientEmail,
        clientPhone: data.clientPhone,
        clientAddress: data.clientAddress,
        dueDate: new Date(data.dueDate),
        notes: data.notes || null,
        lineItems: {
          create: data.lineItems.map((item) => ({
            description: item.description,
            quantity: item.quantity,
            unitPrice: item.unitPrice,
          })),
        },
      },
    });
  });
```

**Verify:** updateInvoice uses transaction. Run `npm run typecheck`

**Commit:** `feat(4.1.1a): wrap updateInvoice in database transaction`

---

### 4.1.1b Handle transaction errors in updateInvoice

**File:** `src/app/actions/invoices.ts`
**Action:** Add try-catch around transaction

**Wrap the transaction in error handling:**
```typescript
export async function updateInvoice(id: string, data: InvoiceInput) {
  const userId = await getCurrentUserId();
  const log = createLogger({ action: "updateInvoice", userId, invoiceId: id });

  // ... validation code ...

  // Verify ownership
  const existing = await db.invoice.findFirst({
    where: { id, userId },
  });

  if (!existing) {
    throw new Error("Invoice not found");
  }

  try {
    await db.$transaction(async (tx) => {
      await tx.lineItem.deleteMany({ where: { invoiceId: id } });

      await tx.invoice.update({
        where: { id },
        data: {
          // ... data fields ...
        },
      });
    });

    log.info("Invoice updated successfully");
    revalidatePath("/");
    revalidatePath(`/invoices/${id}`);
  } catch (error) {
    log.error({ error }, "Transaction failed: unable to update invoice");
    throw new Error("Failed to update invoice. Please try again.");
  }
}
```

**Verify:** Transaction errors are caught and logged. Run `npm run typecheck`

**Commit:** `feat(4.1.1b): add error handling for updateInvoice transaction`

---

### 4.1.2a Wrap deleteInvoice in transaction

**File:** `src/app/actions/invoices.ts`
**Action:** Modify deleteInvoice to use transaction

**Note:** Since LineItem has cascade delete, a simple transaction isn't strictly necessary, but it's good practice and allows for adding audit logging.

**Replace deleteInvoice with:**
```typescript
export async function deleteInvoice(id: string) {
  const userId = await getCurrentUserId();
  const log = createLogger({ action: "deleteInvoice", userId, invoiceId: id });

  log.info("Deleting invoice");

  // Verify ownership
  const existing = await db.invoice.findFirst({
    where: { id, userId },
    select: { id: true, invoiceNumber: true },
  });

  if (!existing) {
    throw new Error("Invoice not found");
  }

  try {
    await db.$transaction(async (tx) => {
      // LineItems are cascade deleted, but explicit delete is clearer
      await tx.lineItem.deleteMany({ where: { invoiceId: id } });
      await tx.invoice.delete({ where: { id } });
    });

    log.info({ invoiceNumber: existing.invoiceNumber }, "Invoice deleted successfully");
    revalidatePath("/");
    redirect("/");
  } catch (error) {
    log.error({ error }, "Transaction failed: unable to delete invoice");
    throw new Error("Failed to delete invoice. Please try again.");
  }
}
```

**Verify:** deleteInvoice uses transaction. Run `npm run typecheck`

**Commit:** `feat(4.1.2a): wrap deleteInvoice in database transaction`

---

### 4.1.2b Add pre-delete checks in transaction

**File:** `src/app/actions/invoices.ts`
**Action:** Already done in previous task (ownership check before transaction)

**Additional check: prevent deleting paid invoices (optional business rule):**
```typescript
  const existing = await db.invoice.findFirst({
    where: { id, userId },
    select: { id: true, invoiceNumber: true, status: true },
  });

  if (!existing) {
    throw new Error("Invoice not found");
  }

  if (existing.status === "paid") {
    throw new Error("Cannot delete a paid invoice. Archive it instead.");
  }
```

**Verify:** Pre-delete checks are in place. Run `npm run typecheck`

**Commit:** `feat(4.1.2b): add pre-delete validation checks`

---

### 4.1.3a Add version field for optimistic locking

**File:** `prisma/schema.prisma`
**Action:** Add version field to Invoice model

**Find the Invoice model and add:**
```prisma
model Invoice {
  id            String     @id @default(cuid())
  userId        String
  invoiceNumber String     @unique
  version       Int        @default(0)   // Add this line
  // ... rest of fields ...
}
```

**Run migrations:**
```bash
npx prisma db push
npx prisma generate
```

**Verify:** Invoice model has version field

**Commit:** `feat(4.1.3a): add version field to Invoice for optimistic locking`

---

### 4.1.3b Implement optimistic locking in updateInvoice

**File:** `src/app/actions/invoices.ts`
**Action:** Modify updateInvoice to check and increment version

**Update InvoiceInput type to include version:**
```typescript
export type InvoiceInput = {
  // ... existing fields ...
  version?: number; // For optimistic locking
};
```

**Modify the transaction to use version:**
```typescript
export async function updateInvoice(id: string, data: InvoiceInput) {
  const userId = await getCurrentUserId();
  const log = createLogger({ action: "updateInvoice", userId, invoiceId: id });

  // ... validation code ...

  // Verify ownership and get current version
  const existing = await db.invoice.findFirst({
    where: { id, userId },
    select: { id: true, version: true },
  });

  if (!existing) {
    throw new Error("Invoice not found");
  }

  // Check version for optimistic locking
  if (data.version !== undefined && data.version !== existing.version) {
    throw new Error("Invoice was modified by another user. Please refresh and try again.");
  }

  try {
    await db.$transaction(async (tx) => {
      // Double-check version inside transaction
      const current = await tx.invoice.findUnique({
        where: { id },
        select: { version: true },
      });

      if (current && data.version !== undefined && current.version !== data.version) {
        throw new Error("Concurrent modification detected");
      }

      await tx.lineItem.deleteMany({ where: { invoiceId: id } });

      await tx.invoice.update({
        where: { id },
        data: {
          clientId: data.clientId,
          clientName: data.clientName,
          clientEmail: data.clientEmail,
          clientPhone: data.clientPhone,
          clientAddress: data.clientAddress,
          dueDate: new Date(data.dueDate),
          notes: data.notes || null,
          version: { increment: 1 }, // Increment version
          lineItems: {
            create: data.lineItems.map((item) => ({
              description: item.description,
              quantity: item.quantity,
              unitPrice: item.unitPrice,
            })),
          },
        },
      });
    });

    log.info("Invoice updated successfully");
    revalidatePath("/");
    revalidatePath(`/invoices/${id}`);
  } catch (error) {
    if (error instanceof Error && error.message.includes("modification")) {
      throw error; // Re-throw version mismatch errors
    }
    log.error({ error }, "Transaction failed: unable to update invoice");
    throw new Error("Failed to update invoice. Please try again.");
  }
}
```

**Verify:** Optimistic locking is implemented. Run `npm run typecheck`

**Commit:** `feat(4.1.3b): implement optimistic locking in updateInvoice`

---

### 4.1.4a Create transaction helper utility

**File:** `src/lib/transaction.ts`
**Action:** Create new file

**Code:**
```typescript
import { db } from "@/lib/db";
import { createLogger } from "@/lib/logger";
import { Prisma } from "@prisma/client";

export type TransactionClient = Omit<
  typeof db,
  "$connect" | "$disconnect" | "$on" | "$transaction" | "$use" | "$extends"
>;

export type TransactionCallback<T> = (tx: TransactionClient) => Promise<T>;

export type TransactionOptions = {
  maxRetries?: number;
  timeout?: number;
  isolationLevel?: Prisma.TransactionIsolationLevel;
};

const DEFAULT_OPTIONS: Required<TransactionOptions> = {
  maxRetries: 3,
  timeout: 5000,
  isolationLevel: Prisma.TransactionIsolationLevel.ReadCommitted,
};

export async function withTransaction<T>(
  callback: TransactionCallback<T>,
  options: TransactionOptions = {}
): Promise<T> {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const log = createLogger({ action: "transaction" });

  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= opts.maxRetries; attempt++) {
    try {
      return await db.$transaction(callback, {
        timeout: opts.timeout,
        isolationLevel: opts.isolationLevel,
      });
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      // Check if error is retryable (deadlock, serialization failure)
      const isRetryable =
        error instanceof Prisma.PrismaClientKnownRequestError &&
        ["P2034"].includes(error.code);

      if (!isRetryable || attempt === opts.maxRetries) {
        log.error(
          { error, attempt, maxRetries: opts.maxRetries },
          "Transaction failed"
        );
        throw lastError;
      }

      log.warn({ attempt, maxRetries: opts.maxRetries }, "Transaction failed, retrying");

      // Exponential backoff
      await new Promise((resolve) =>
        setTimeout(resolve, Math.pow(2, attempt) * 100)
      );
    }
  }

  throw lastError || new Error("Transaction failed");
}
```

**Verify:** File exists and TypeScript compiles (`npm run typecheck`)

**Commit:** `feat(4.1.4a): create transaction helper utility with retry logic`

---

### 4.1.4b Add transaction retry logic

**File:** `src/app/actions/invoices.ts`
**Action:** Use the transaction helper in updateInvoice

**Import the helper:**
```typescript
import { withTransaction } from "@/lib/transaction";
```

**Replace the direct $transaction call with withTransaction:**
```typescript
  try {
    await withTransaction(async (tx) => {
      // Double-check version inside transaction
      if (data.version !== undefined) {
        const current = await tx.invoice.findUnique({
          where: { id },
          select: { version: true },
        });

        if (current && current.version !== data.version) {
          throw new Error("Concurrent modification detected");
        }
      }

      await tx.lineItem.deleteMany({ where: { invoiceId: id } });

      await tx.invoice.update({
        where: { id },
        data: {
          // ... data fields ...
          version: { increment: 1 },
          // ...
        },
      });
    });
    // ...
  }
```

**Verify:** updateInvoice uses withTransaction. Run `npm run typecheck`

**Commit:** `feat(4.1.4b): use transaction helper with retry logic in actions`

---

## Progress Log

| Timestamp | Agent | Action | Task | Commit |
|-----------|-------|--------|------|--------|
| | | | | |
